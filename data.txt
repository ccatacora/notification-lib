
Desglose de Responsabilidades
1. El Paquete api

Contiene los contratos. Si un desarrollador quiere crear su propio proveedor (por ejemplo, para un sistema interno), solo necesita implementar las interfaces de este paquete. No depende de nada m√°s.
2. El Paquete core

Es el motor. Aqu√≠ reside el NotificationService. Su trabajo es gestionar el ciclo de vida del env√≠o, manejar errores y, opcionalmente, llevar un log de las notificaciones enviadas.
3. El Paquete providers

Aqu√≠ agrupamos las implementaciones por tecnolog√≠a.

    Tip de Arquitectura: En una librer√≠a muy grande, estos proveedores podr√≠an incluso estar en m√≥dulos separados (ej. notification-email-sendgrid) para que el usuario final no tenga dependencias de Mailgun si solo va a usar SendGrid.


Justificaci√≥n T√©cnica de Java 21

    Virtual Threads (newVirtualThreadPerTaskExecutor): En una librer√≠a de notificaciones, el 99% del
    tiempo se pierde esperando la respuesta de una API externa (HTTP). Los hilos virtuales permiten que tu
    librer√≠a maneje miles de env√≠os simult√°neos sin agotar la memoria del servidor del cliente.

    Records: Reemplazamos clases pesadas por estructuras de datos concisas, inmutables y seguras para hilos.

    Pattern Matching for Switch: (Opcional en el futuro) permitir√° manejar de forma muy elegante
     diferentes tipos de errores seg√∫n el proveedor.

*************************
Notification Lib (Java 21)  ---esto lo puse en el readmee

Una librer√≠a de notificaciones agn√≥stica, ligera y altamente escalable dise√±ada para ecosistemas Java modernos.
üöÄ Caracter√≠sticas Principal
    Java 21 Ready: Aprovecha Virtual Threads para un env√≠o masivo de notificaciones sin bloquear hilos de plataforma.
    Agn√≥stica: Cero dependencias de frameworks como Spring, Quarkus o Micronaut.
    Extensible: A√±ade nuevos canales (Telegram, WhatsApp, Webhooks) simplemente implementando una interfaz.
    Inmutable: Uso de records para garantizar la integridad de los datos.

------estructura del proyecto

com.notification
‚îú‚îÄ‚îÄ api/          # Contratos p√∫blicos y modelos (Records)
‚îú‚îÄ‚îÄ core/         # Orquestador y l√≥gica de hilos virtuales
‚îî‚îÄ‚îÄ providers/    # Implementaciones concretas (Mailgun, Twilio, etc.)

*****************************
Decisiones de Dise√±o (Justificaci√≥n)

    Thread-Safety: Se utiliza CopyOnWriteArrayList para el registro de proveedores, permitiendo registros
     en caliente sin riesgos de concurrencia.

    Virtual Threads: Se eligi√≥ Executors.newVirtualThreadPerTaskExecutor() porque las notificaciones son
    tareas de I/O Bound. Esto permite que la aplicaci√≥n que consuma la librer√≠a pueda escalar horizontalmente sin
     preocuparse por el thread pool.

    Records: Se utilizan para el modelo Notification eliminando el c√≥digo repetitivo y asegurando que una
     notificaci√≥n no cambie una vez creada.

¬øTe gustar√≠a que preparemos un archivo JAR de ejemplo o prefieres que implementemos una pol√≠tica de
 reintentos (Retry Policy) autom√°tica para los proveedores que fallen?

********************************
para generar java doc
mvn javadoc:javadoc
***********************************

Excelente elecci√≥n. Usar Java 21 (LTS) nos permite aprovechar los Virtual Threads (hilos virtuales), lo cual es ideal para una
librer√≠a de notificaciones donde el env√≠o suele ser una operaci√≥n bloqueante de Entrada/Salida (I/O). Con hilos virtuales,
tu librer√≠a podr√≠a escalar a millones de notificaciones con un consumo de recursos m√≠nimo.

A continuaci√≥n, presento la implementaci√≥n completa siguiendo est√°ndares profesionales, usando Records, Sealed Interfaces y
Javadoc exhaustivo.

***************
Beneficios de este dise√±o en Java 21:
    Resiliencia: La librer√≠a no se rinde al primer error de red.
    Eficiencia de Recursos: Gracias a los Virtual Threads, aunque tengamos 10,000
    notificaciones esperando su turno de reintento (Thread.sleep), el consumo de memoria ser√° m√≠nimo porque
     no estamos reteniendo hilos pesados del sistema operativo.
    Transparencia: El usuario final de la librer√≠a simplemente llama a sendAsync y la librer√≠a se encarga de la
    complejidad del reintento de forma interna.
****************
Excelente elecci√≥n. Implementar una Pol√≠tica de Reintentos (Retry Policy) es lo que diferencia una librer√≠a
b√°sica de una de grado productivo. En el env√≠o de notificaciones (redes, APIs externas), los fallos temporales son comunes.
Para mantener la librer√≠a agn√≥stica, implementaremos un mecanismo de Backoff Exponencial (esperar cada vez m√°s tiempo
 entre reintentos) usando la l√≥gica nativa de Java 21.
Aqu√≠ tienes la implementaci√≥n con Javadoc completo:
***************
NotificationPriority

¬øPor qu√© incluir esta informaci√≥n?

    Priorizaci√≥n en Colas (weight): Si en el futuro decides implementar una PriorityBlockingQueue
     dentro de tu librer√≠a para procesar mensajes, el campo weight permitir√° que las notificaciones URGENT
     se muevan al principio de la fila autom√°ticamente.

    Gesti√≥n de Throttling (bypassThrottling): Muchos proveedores (como Amazon SES o Twilio) tienen l√≠mites de
    env√≠o por segundo. Una notificaci√≥n de marketing (LOW) puede esperar en una cola si alcanzas el l√≠mite, pero
     un c√≥digo de acceso (URGENT) deber√≠a intentar enviarse ignorando las reglas de pausa.

    Selecci√≥n de Proveedor: Tu NotificationService podr√≠a usar la prioridad para elegir el canal.
        Ejemplo: Si es URGENT, enviar por SMS + Email. Si es LOW, solo Email.
*************
